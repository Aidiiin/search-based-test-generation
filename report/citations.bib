
% Journals

% First the Full Name is given, then the abbreviation used in the AMS Math
% Reviews, with an indication if it could not be found there.
% Note the 2nd overwrites the 1st, so swap them if you want the full name.

 %{AMS}
 @String{AMSTrans = "American Mathematical Society Translations" }
 @String{AMSTrans = "Amer. Math. Soc. Transl." }
 @String{BullAMS = "Bulletin of the American Mathematical Society" }
 @String{BullAMS = "Bull. Amer. Math. Soc." }
 @String{ProcAMS = "Proceedings of the American Mathematical Society" }
 @String{ProcAMS = "Proc. Amer. Math. Soc." }
 @String{TransAMS = "Transactions of the American Mathematical Society" }
 @String{TransAMS = "Trans. Amer. Math. Soc." }

 %ACM
 @String{CACM = "Communications of the {ACM}" }
 @String{CACM = "Commun. {ACM}" }
 @String{CompServ = "Comput. Surveys" }
 @String{JACM = "J. ACM" }
 @String{ACMMathSoft = "{ACM} Transactions on Mathematical Software" }
 @String{ACMMathSoft = "{ACM} Trans. Math. Software" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newsletter" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newslett." }

 @String{AmerSocio = "American Journal of Sociology" }
 @String{AmerStatAssoc = "Journal of the American Statistical Association" }
 @String{AmerStatAssoc = "J. Amer. Statist. Assoc." }
 @String{ApplMathComp = "Applied Mathematics and Computation" }
 @String{ApplMathComp = "Appl. Math. Comput." }
 @String{AmerMathMonthly = "American Mathematical Monthly" }
 @String{AmerMathMonthly = "Amer. Math. Monthly" }
 @String{BIT = "{BIT}" }
 @String{BritStatPsych = "British Journal of Mathematical and Statistical
          Psychology" }
 @String{BritStatPsych = "Brit. J. Math. Statist. Psych." }
 @String{CanMathBull = "Canadian Mathematical Bulletin" }
 @String{CanMathBull = "Canad. Math. Bull." }
 @String{CompApplMath = "Journal of Computational and Applied Mathematics" }
 @String{CompApplMath = "J. Comput. Appl. Math." }
 @String{CompPhys = "Journal of Computational Physics" }
 @String{CompPhys = "J. Comput. Phys." }
 @String{CompStruct = "Computers and Structures" }
 @String{CompStruct = "Comput. \& Structures" }
 @String{CompJour = "The Computer Journal" }
 @String{CompJour = "Comput. J." }
 @String{CompSysSci = "Journal of Computer and System Sciences" }
 @String{CompSysSci = "J. Comput. System Sci." }
 @String{Computing = "Computing" }
 @String{ContempMath = "Contemporary Mathematics" }
 @String{ContempMath = "Contemp. Math." }
 @String{Crelle = "Crelle's Journal" }
 @String{GiornaleMath = "Giornale di Mathematiche" }
 @String{GiornaleMath = "Giorn. Mat." } % didn't find in AMS MR., ibid.

 %IEEE
 @String{Computer = "{IEEE} Computer" }
 @String{IEEETransComp = "{IEEE} Transactions on Computers" }
 @String{IEEETransComp = "{IEEE} Trans. Comput." }
 @String{IEEETransAC = "{IEEE} Transactions on Automatic Control" }
 @String{IEEETransAC = "{IEEE} Trans. Automat. Control" }
 @String{IEEESpec = "{IEEE} Spectrum" } % didn't find in AMS MR
 @String{ProcIEEE = "Proceedings of the {IEEE}" }
 @String{ProcIEEE = "Proc. {IEEE}" } % didn't find in AMS MR
 @String{IEEETransAeroElec = "{IEEE} Transactions on Aerospace and Electronic
     Systems" }
 @String{IEEETransAeroElec = "{IEEE} Trans. Aerospace Electron. Systems" }

 @String{IMANumerAna = "{IMA} Journal of Numerical Analysis" }
 @String{IMANumerAna = "{IMA} J. Numer. Anal." }
 @String{InfProcLet = "Information Processing Letters" }
 @String{InfProcLet = "Inform. Process. Lett." }
 @String{InstMathApp = "Journal of the Institute of Mathematics and
     its Applications" }
 @String{InstMathApp = "J. Inst. Math. Appl." }
 @String{IntControl = "International Journal of Control" }
 @String{IntControl = "Internat. J. Control" }
 @String{IntNumerEng = "International Journal for Numerical Methods in
     Engineering" }
 @String{IntNumerEng = "Internat. J. Numer. Methods Engrg." }
 @String{IntSuper = "International Journal of Supercomputing Applications" }
 @String{IntSuper = "Internat. J. Supercomputing Applic." } % didn't find
%% in AMS MR
 @String{Kibernetika = "Kibernetika" }
 @String{JResNatBurStand = "Journal of Research of the National Bureau
     of Standards" }
 @String{JResNatBurStand = "J. Res. Nat. Bur. Standards" }
 @String{LinAlgApp = "Linear Algebra and its Applications" }
 @String{LinAlgApp = "Linear Algebra Appl." }
 @String{MathAnaAppl = "Journal of Mathematical Analysis and Applications" }
 @String{MathAnaAppl = "J. Math. Anal. Appl." }
 @String{MathAnnalen = "Mathematische Annalen" }
 @String{MathAnnalen = "Math. Ann." }
 @String{MathPhys = "Journal of Mathematical Physics" }
 @String{MathPhys = "J. Math. Phys." }
 @String{MathComp = "Mathematics of Computation" }
 @String{MathComp = "Math. Comp." }
 @String{MathScand = "Mathematica Scandinavica" }
 @String{MathScand = "Math. Scand." }
 @String{TablesAidsComp = "Mathematical Tables and Other Aids to Computation" }
 @String{TablesAidsComp = "Math. Tables Aids Comput." }
 @String{NumerMath = "Numerische Mathematik" }
 @String{NumerMath = "Numer. Math." }
 @String{PacificMath = "Pacific Journal of Mathematics" }
 @String{PacificMath = "Pacific J. Math." }
 @String{ParDistComp = "Journal of Parallel and Distributed Computing" }
 @String{ParDistComp = "J. Parallel and Distrib. Comput." } % didn't find
%% in AMS MR
 @String{ParComputing = "Parallel Computing" }
 @String{ParComputing = "Parallel Comput." }
 @String{PhilMag = "Philosophical Magazine" }
 @String{PhilMag = "Philos. Mag." }
 @String{ProcNAS = "Proceedings of the National Academy of Sciences
                    of the USA" }
 @String{ProcNAS = "Proc. Nat. Acad. Sci. U. S. A." }
 @String{Psychometrika = "Psychometrika" }
 @String{QuartMath = "Quarterly Journal of Mathematics, Oxford, Series (2)" }
 @String{QuartMath = "Quart. J. Math. Oxford Ser. (2)" }
 @String{QuartApplMath = "Quarterly of Applied Mathematics" }
 @String{QuartApplMath = "Quart. Appl. Math." }
 @String{RevueInstStat = "Review of the International Statisical Institute" }
 @String{RevueInstStat = "Rev. Inst. Internat. Statist." }

 %SIAM
 @String{JSIAM = "Journal of the Society for Industrial and Applied
     Mathematics" }
 @String{JSIAM = "J. Soc. Indust. Appl. Math." }
 @String{JSIAMB = "Journal of the Society for Industrial and Applied
     Mathematics, Series B, Numerical Analysis" }
 @String{JSIAMB = "J. Soc. Indust. Appl. Math. Ser. B Numer. Anal." }
 @String{SIAMAlgMeth = "{SIAM} Journal on Algebraic and Discrete Methods" }
 @String{SIAMAlgMeth = "{SIAM} J. Algebraic Discrete Methods" }
 @String{SIAMAppMath = "{SIAM} Journal on Applied Mathematics" }
 @String{SIAMAppMath = "{SIAM} J. Appl. Math." }
 @String{SIAMComp = "{SIAM} Journal on Computing" }
 @String{SIAMComp = "{SIAM} J. Comput." }
 @String{SIAMMatrix = "{SIAM} Journal on Matrix Analysis and Applications" }
 @String{SIAMMatrix = "{SIAM} J. Matrix Anal. Appl." }
 @String{SIAMNumAnal = "{SIAM} Journal on Numerical Analysis" }
 @String{SIAMNumAnal = "{SIAM} J. Numer. Anal." }
 @String{SIAMReview = "{SIAM} Review" }
 @String{SIAMReview = "{SIAM} Rev." }
 @String{SIAMSciStat = "{SIAM} Journal on Scientific and Statistical
     Computing" }
 @String{SIAMSciStat = "{SIAM} J. Sci. Statist. Comput." }

 @String{SoftPracExp = "Software Practice and Experience" }
 @String{SoftPracExp = "Software Prac. Experience" } % didn't find in AMS MR
 @String{StatScience = "Statistical Science" }
 @String{StatScience = "Statist. Sci." }
 @String{Techno = "Technometrics" }
 @String{USSRCompMathPhys = "{USSR} Computational Mathematics and Mathematical
     Physics" }
 @String{USSRCompMathPhys = "{U. S. S. R.} Comput. Math. and Math. Phys." }
 @String{VLSICompSys = "Journal of {VLSI} and Computer Systems" }
 @String{VLSICompSys = "J. {VLSI} Comput. Syst." }
 @String{ZAngewMathMech = "Zeitschrift fur Angewandte Mathematik und
     Mechanik" }
 @String{ZAngewMathMech = "Z. Angew. Math. Mech." }
 @String{ZAngewMathPhys = "Zeitschrift fur Angewandte Mathematik und Physik" }
 @String{ZAngewMathPhys = "Z. Angew. Math. Phys." }

% Publishers % ================================================= |

 @String{Academic = "Academic Press" }
 @String{ACMPress = "{ACM} Press" }
 @String{AdamHilger = "Adam Hilger" }
 @String{AddisonWesley = "Addison-Wesley" }
 @String{AllynBacon = "Allyn and Bacon" }
 @String{AMS = "American Mathematical Society" }
 @String{Birkhauser = "Birkha{\"u}ser" }
 @String{CambridgePress = "Cambridge University Press" }
 @String{Chelsea = "Chelsea" }
 @String{ClaredonPress = "Claredon Press" }
 @String{DoverPub = "Dover Publications" }
 @String{Eyolles = "Eyolles" }
 @String{HoltRinehartWinston = "Holt, Rinehart and Winston" }
 @String{Interscience = "Interscience" }
 @String{JohnsHopkinsPress = "The Johns Hopkins University Press" }
 @String{JohnWileySons = "John Wiley and Sons" }
 @String{Macmillan = "Macmillan" }
 @String{MathWorks = "The Math Works Inc." }
 @String{McGrawHill = "McGraw-Hill" }
 @String{NatBurStd = "National Bureau of Standards" }
 @String{NorthHolland = "North-Holland" }
 @String{OxfordPress = "Oxford University Press" }  %address Oxford or London?
 @String{PergamonPress = "Pergamon Press" }
 @String{PlenumPress = "Plenum Press" }
 @String{PrenticeHall = "Prentice-Hall" }
 @String{SIAMPub = "{SIAM} Publications" }
 @String{Springer = "Springer-Verlag" }
 @String{TexasPress = "University of Texas Press" }
 @String{VanNostrand = "Van Nostrand" }
 @String{WHFreeman = "W. H. Freeman and Co." }

%Entries

@inproceedings{6004309,
  author    = {G. {Fraser} and A. {Arcuri}},
  booktitle = {2011 11th International Conference on Quality Software},
  title     = {Evolutionary Generation of Whole Test Suites},
  year      = {2011},
  volume    = {},
  number    = {},
  pages     = {31-40},
  doi       = {10.1109/QSIC.2011.19}
}
@article{CAMPOS2018207,
title = "An empirical evaluation of evolutionary algorithms for unit test suite generation",
journal = "Information and Software Technology",
volume = "104",
pages = "207 - 235",
year = "2018",
issn = "0950-5849",
doi = "https://doi.org/10.1016/j.infsof.2018.08.010",
url = "http://www.sciencedirect.com/science/article/pii/S0950584917304858",
author = "José Campos and Yan Ge and Nasser Albunian and Gordon Fraser and Marcelo Eler and Andrea Arcuri",
keywords = "Evolutionary algorithms, Test suite generation, Empirical study",
abstract = "Context
Evolutionary algorithms have been shown to be effective at generating unit test suites optimised for code coverage. While many specific aspects of these algorithms have been evaluated in detail (e.g., test length and different kinds of techniques aimed at improving performance, like seeding), the influence of the choice of evolutionary algorithm has to date seen less attention in the literature.
Objective
Since it is theoretically impossible to design an algorithm that is the best on all possible problems, a common approach in software engineering problems is to first try the most common algorithm, a genetic algorithm, and only afterwards try to refine it or compare it with other algorithms to see if any of them is more suited for the addressed problem. The objective of this paper is to perform this analysis, in order to shed light on the influence of the search algorithm applied for unit test generation.
Method
We empirically evaluate thirteen different evolutionary algorithms and two random approaches on a selection of non-trivial open source classes. All algorithms are implemented in the EvoSuite test generation tool, which includes recent optimisations such as the use of an archive during the search and optimisation for multiple coverage criteria.
Results
Our study shows that the use of a test archive makes evolutionary algorithms clearly better than random testing, and it confirms that the DynaMOSA many-objective search algorithm is the most effective algorithm for unit test generation.
Conclusion
Our results show that the choice of algorithm can have a substantial influence on the performance of whole test suite optimisation. Although we can make a recommendation on which algorithm to use in practice, no algorithm is clearly superior in all cases, suggesting future work on improved search algorithms for unit test generation."
}

@article{Tuning13,
  year={2013},
  issn={1382-3256},
  journal={Empirical Software Engineering},
  doi={10.1007/s10664-013-9249-9},
  title={Parameter tuning or default values? An empirical investigation in search-based software engineering},
  url={http://dx.doi.org/10.1007/s10664-013-9249-9},
  publisher={Springer US},
  keywords={Search-based software engineering; Test data generation; Object-oriented; Unit testing; Tuning; EvoSuite; Java; Response surface; Design of experiments},
  author={Arcuri, Andrea and Fraser, Gordon},
  language={English}
}

@Article{emse16_effectiveness,
  author="Rojas, Jos{\'e} Miguel
  and Vivanti, Mattia
  and Arcuri, Andrea
  and Fraser, Gordon",
  title="A detailed investigation of the effectiveness of whole test suite generation",
  journal="Empirical Software Engineering",
  year="2016",
  pages="1--42",
  abstract="A common application of search-based software testing is to generate test cases for all goals defined by a coverage criterion (e.g., lines, branches, mutants). Rather than generating one test case at a time for each of these goals individually, whole test suite generation optimizes entire test suites towards satisfying all goals at the same time. There is evidence that the overall coverage achieved with this approach is superior to that of targeting individual coverage goals. Nevertheless, there remains some uncertainty on (a) whether the results generalize beyond branch coverage, (b) whether the whole test suite approach might be inferior to a more focused search for some particular coverage goals, and (c) whether generating whole test suites could be optimized by only targeting coverage goals not already covered. In this paper, we perform an in-depth analysis to study these questions. An empirical study on 100 Java classes using three different coverage criteria reveals that indeed there are some testing goals that are only covered by the traditional approach, although their number is only very small in comparison with those which are exclusively covered by the whole test suite approach. We find that keeping an archive of already covered goals along with the tests covering them and focusing the search on uncovered goals overcomes this small drawback on larger classes, leading to an improved overall effectiveness of whole test suite generation.",
  issn="1573-7616",
  doi="10.1007/s10664-015-9424-2",
  url="http://dx.doi.org/10.1007/s10664-015-9424-2"
}

@ARTICLE{7840029,  
  author={A. {Panichella} and F. M. {Kifetew} and P. {Tonella}},  
  journal={IEEE Transactions on Software Engineering},   
  title={Automated Test Case Generation as a Many-Objective Optimisation Problem with Dynamic Selection of the Targets},   
  year={2018},  
  volume={44},  
  number={2},  
  pages={122-158},  
  doi={10.1109/TSE.2017.2663435}
}

@article{Arcuri_2017,
   title={Many Independent Objective (MIO) Algorithm for Test Suite Generation},
   ISBN={9783319662992},
   ISSN={1611-3349},
   url={http://dx.doi.org/10.1007/978-3-319-66299-2_1},
   DOI={10.1007/978-3-319-66299-2_1},
   journal={Lecture Notes in Computer Science},
   publisher={Springer International Publishing},
   author={Arcuri, Andrea},
   year={2017},
   pages={3–17}
}

@article{STVR_seeding,
  author = {Rojas, Jos{\'e} Miguel and Fraser, Gordon and Arcuri, Andrea},
  title = {Seeding strategies in search-based unit test generation},
  journal = {Software Testing, Verification and Reliability},
  issn = {1099-1689},
  url = {http://dx.doi.org/10.1002/stvr.1601},
  doi = {10.1002/stvr.1601},
  pages = {n/a--n/a},
  keywords = {test case generation, search-based testing, testing classes, search-based software engineering, JUnit, Java},
  year = {2016},
}

@article{10.1145/2379776.2379787,
  author = {Harman, Mark and Mansouri, S. Afshin and Zhang, Yuanyuan},
  title = {Search-Based Software Engineering: Trends, Techniques and Applications},
  year = {2012},
  issue_date = {November 2012},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {45},
  number = {1},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/2379776.2379787},
  doi = {10.1145/2379776.2379787},
  abstract = {In the past five years there has been a dramatic increase in work on Search-Based Software Engineering (SBSE), an approach to Software Engineering (SE) in which Search-Based Optimization (SBO) algorithms are used to address problems in SE. SBSE has been applied to problems throughout the SE lifecycle, from requirements and project planning to maintenance and reengineering. The approach is attractive because it offers a suite of adaptive automated and semiautomated solutions in situations typified by large complex problem spaces with multiple competing and conflicting objectives.This article1 provides a review and classification of literature on SBSE. The work identifies research trends and relationships between the techniques applied and the applications to which they have been applied and highlights gaps in the literature and avenues for further research.},
  journal = {ACM Comput. Surv.},
  month = dec,
  articleno = {11},
  numpages = {61},
  keywords = {search-based techniques, survey, Software engineering}
}

@Inbook{Harman2012,
  author="Harman, Mark
  and McMinn, Phil
  and de Souza, Jerffeson Teixeira
  and Yoo, Shin",
  editor="Meyer, Bertrand
  and Nordio, Martin",
  title="Search Based Software Engineering: Techniques, Taxonomy, Tutorial",
  bookTitle="Empirical Software Engineering and Verification: International Summer Schools, LASER 2008-2010, Elba Island, Italy, Revised Tutorial Lectures",
  year="2012",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="1--59",
  abstract="The aim of Search Based Software Engineering (SBSE) research is to move software engineering problems from human-based search to machine-based search, using a variety of techniques from the metaheuristic search, operations research and evolutionary computation paradigms. The idea is to exploit humans' creativity and machines' tenacity and reliability, rather than requiring humans to perform the more tedious, error prone and thereby costly aspects of the engineering process. SBSE can also provide insights and decision support. This tutorial will present the reader with a step-by-step guide to the application of SBSE techniques to Software Engineering. It assumes neither previous knowledge nor experience with Search Based Optimisation. The intention is that the tutorial will cover sufficient material to allow the reader to become productive in successfully applying search based optimisation to a chosen Software Engineering problem of interest.",
  isbn="978-3-642-25231-0",
  doi="10.1007/978-3-642-25231-0_1",
  url="https://doi.org/10.1007/978-3-642-25231-0_1"
}

@ARTICLE{57624,
  author={B. {Korel}},
  journal={IEEE Transactions on Software Engineering}, 
  title={Automated software test data generation}, 
  year={1990},
  volume={16},
  number={8},
  pages={870-879},
  doi={10.1109/32.57624}
}

@inproceedings{10.1145/1276958.1277172,
  author = {Ayari, Kamel and Bouktif, Salah and Antoniol, Giuliano},
  title = {Automatic Mutation Test Input Data Generation via Ant Colony},
  year = {2007},
  isbn = {9781595936974},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1276958.1277172},
  doi = {10.1145/1276958.1277172},
  abstract = {Fault-based testing is often advocated to overcome limitations ofother testing approaches; however it is also recognized as beingexpensive. On the other hand, evolutionary algorithms have beenproved suitable for reducing the cost of data generation in the contextof coverage based testing. In this paper, we propose a newevolutionary approach based on ant colony optimization for automatictest input data generation in the context of mutation testingto reduce the cost of such a test strategy. In our approach the antcolony optimization algorithm is enhanced by a probability densityestimation technique. We compare our proposal with otherevolutionary algorithms, e.g., Genetic Algorithm. Our preliminaryresults on JAVA testbeds show that our approach performed significantlybetter than other alternatives.},
  booktitle = {Proceedings of the 9th Annual Conference on Genetic and Evolutionary Computation},
  pages = {1074–1081},
  numpages = {8},
  keywords = {search based testing, mutation testing, test input data generation, ant colony optimization},
  location = {London, England},
  series = {GECCO '07}
}

@article{10.1145/1013886.1007528,
  author = {Tonella, Paolo},
  title = {Evolutionary Testing of Classes},
  year = {2004},
  issue_date = {July 2004},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {29},
  number = {4},
  issn = {0163-5948},
  url = {https://doi.org/10.1145/1013886.1007528},
  doi = {10.1145/1013886.1007528},
  abstract = {Object oriented programming promotes reuse of classes in multiple contexts. Thus, a class is designed and implemented with several usage scenarios in mind, some of which possibly open and generic. Correspondingly, the unit testing of classes cannot make too strict assumptions on the actual method invocation sequences, since these vary from application to application.In this paper, a genetic algorithm is exploited to automatically produce test cases for the unit testing of classes in a generic usage scenario. Test cases are described by chromosomes, which include information on which objects to create, which methods to invoke and which values to use as inputs. The proposed algorithm mutates them with the aim of maximizing a given coverage measure. The implementation of the algorithm and its application to classes from the Java standard library are described.},
  journal = {SIGSOFT Softw. Eng. Notes},
  month = jul,
  pages = {119–128},
  numpages = {10},
  keywords = {genetic algorithms, automated test case generation, object-oriented testing}
}


@misc{ web:commonscli,
  author = {The Apache Software Foundation},
  title = {Commons CLI},
  year = {2019},
  url = {https://commons.apache.org/proper/commons-cli/}
}
@misc{ web:commonscodec,
  author = {The Apache Software Foundation},
  title = {Commons Codec},
  year = {2020},
  url = {https://commons.apache.org/proper/commons-codec/}
}
@misc{ web:commonsmath,
  author = {The Apache Software Foundation},
  title = {Commons Math},
  year = {2016},
  url = {https://commons.apache.org/proper/commons-math/}
}
@misc{ web:httpreq,
  author = {Kevin Sawicki},
  title = {kevinsawicki/http-request: Java HTTP Request Library},
  year = {2020},
  url = {https://github.com/kevinsawicki/http-request/}
}
@misc{ web:jodatime,
  author = {Joda Org},
  title = {Joda Time},
  year = {2020},
  url = {https://www.joda.org/joda-time/}
}
@misc{ web:jodamoney,
  author = {Joda Org},
  title = {Joda Money},
  year = {2019},
  url = {https://www.joda.org/joda-money/}
}
@misc{ web:jsonjava,
  author = {Sean Leary},
  title = {stleary/JSON-java: A reference implementation of a JSON package in Java},
  year = {2020},
  url = {https://github.com/stleary/JSON-java/}
}
@misc{ web:jsoup,
  author = {Jonathan Hedley},
  title = {jsoup: Java HTML Parser},
  year = {2020},
  url = {https://jsoup.org/}
}
@misc{ web:spatial4j,
  author = {Eclipse Foundation},
  title = {LocationTech Spatial4j},
  year = {2020},
  url = {https://projects.eclipse.org/projects/locationtech.spatial4j/}
}

@misc{ web:vertx,
  author = {Eclipse Foundation},
  title = {Eclipse Vert.x},
  year = {2020},
  url = {https://vertx.io/}
}
